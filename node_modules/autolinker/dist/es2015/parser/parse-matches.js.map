{"version":3,"file":"parse-matches.js","sourceRoot":"","sources":["../../../src/parser/parse-matches.ts"],"names":[],"mappings":"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","sourcesContent":["import { UrlMatch, UrlMatchType } from '../match/url-match';\nimport { Match } from '../match/match';\nimport { assertNever } from '../utils';\nimport {\n    httpSchemeRe,\n    isDomainLabelChar,\n    isDomainLabelStartChar,\n    isPathChar,\n    isSchemeChar,\n    isSchemeStartChar,\n    isUrlSuffixStartChar,\n    isValidIpV4Address,\n    isValidSchemeUrl,\n    isValidTldMatch,\n} from './uri-utils';\nimport {\n    isEmailLocalPartChar,\n    isEmailLocalPartStartChar,\n    isValidEmail,\n    mailtoSchemePrefixRe,\n} from './email-utils';\nimport { EmailMatch } from '../match/email-match';\nimport { HashtagService, isHashtagTextChar, isValidHashtag } from './hashtag-utils';\nimport { HashtagMatch } from '../match/hashtag-match';\nimport { isMentionTextChar, isValidMention, MentionService } from './mention-utils';\nimport { MentionMatch } from '../match/mention-match';\nimport {\n    isPhoneNumberSeparatorChar,\n    isPhoneNumberControlChar,\n    isValidPhoneNumber,\n} from './phone-number-utils';\nimport { PhoneMatch } from '../match/phone-match';\nimport { AnchorTagBuilder } from '../anchor-tag-builder';\nimport type { StripPrefixConfigObj } from '../autolinker';\nimport { Char } from '../char';\nimport {\n    isAlphaNumericOrMarkChar,\n    isCloseBraceChar,\n    isDigitChar,\n    isOpenBraceChar,\n    isUrlSuffixNotAllowedAsFinalChar,\n} from '../char-utils';\n\n// For debugging: search for and uncomment other \"For debugging\" lines\n// import CliTable from 'cli-table';\n\n/**\n * Context object containing all the state needed by the state machine functions.\n *\n * ## Historical note\n *\n * In v4.1.1, we used nested functions to handle the context via closures, but\n * this necessitated re-creating the functions for each call to `parseMatches()`,\n * which made them difficult for v8 to JIT optimize. In v4.1.2, we lifted all of\n * the functions to the top-level scope and passed the context object between\n * them, which allows the functions to be JIT compiled once and reused.\n */\nclass ParseMatchesContext {\n    public charIdx = 0; // Current character index being processed\n\n    public readonly text: string; // The input text being parsed\n    public readonly matches: Match[] = []; // Collection of matches found\n    public readonly tagBuilder: AnchorTagBuilder; // For building anchor tags\n    public readonly stripPrefix: Required<StripPrefixConfigObj>; // Strip prefix configuration\n    public readonly stripTrailingSlash: boolean; // Whether to strip trailing slashes\n    public readonly decodePercentEncoding: boolean; // Whether to decode percent encoding\n    public readonly hashtagServiceName: HashtagService; // Service name for hashtags\n    public readonly mentionServiceName: MentionService; // Service name for mentions\n\n    private _stateMachines: StateMachine[] = []; // Array of active state machines\n    private schemeUrlMachinesCount = 0; // part of an optimization to remove the need to go into a slow code block when unnecessary. Since it's been so long since the initial implementation, not sure that this can ever go above 1, but keeping it as a counter to be safe\n\n    constructor(text: string, args: ParseMatchesArgs) {\n        this.text = text;\n        this.tagBuilder = args.tagBuilder;\n        this.stripPrefix = args.stripPrefix;\n        this.stripTrailingSlash = args.stripTrailingSlash;\n        this.decodePercentEncoding = args.decodePercentEncoding;\n        this.hashtagServiceName = args.hashtagServiceName;\n        this.mentionServiceName = args.mentionServiceName;\n    }\n\n    public get stateMachines(): ReadonlyArray<StateMachine> {\n        return this._stateMachines;\n    }\n\n    public addMachine(stateMachine: StateMachine): void {\n        this._stateMachines.push(stateMachine);\n\n        if (isSchemeUrlStateMachine(stateMachine)) {\n            this.schemeUrlMachinesCount++;\n        }\n    }\n\n    public removeMachine(stateMachine: StateMachine): void {\n        // Performance note: this was originally implemented with Array.prototype.splice()\n        // and mutated the array in place. Switching to filter added ~280ops/sec\n        // on the benchmark, although likely at the expense of GC time. Perhaps\n        // in the future, we implement a rotating array so we never need to move\n        // or clean anything up\n        this._stateMachines = this._stateMachines.filter(m => m !== stateMachine);\n\n        // If we've removed the URL state machine, set the flag to false.\n        // This flag is a quick test that helps us skip a slow section of\n        // code when there is already a URL state machine present.\n        if (isSchemeUrlStateMachine(stateMachine)) {\n            this.schemeUrlMachinesCount--;\n        }\n    }\n\n    public hasSchemeUrlMachine(): boolean {\n        return this.schemeUrlMachinesCount > 0;\n    }\n}\n\n/**\n * Parses URL, email, twitter, mention, and hashtag matches from the given\n * `text`.\n */\nexport function parseMatches(text: string, args: ParseMatchesArgs): Match[] {\n    // Create the context object that will be passed to all state functions\n    const context = new ParseMatchesContext(text, args);\n\n    // For debugging: search for and uncomment other \"For debugging\" lines\n    // const table = new CliTable({\n    //     head: ['charIdx', 'char', 'code', 'type', 'states', 'startIdx', 'reached accept state'],\n    // });\n    for (; context.charIdx < context.text.length; context.charIdx++) {\n        const char = text.charAt(context.charIdx);\n        const charCode = text.charCodeAt(context.charIdx);\n\n        if (context.stateMachines.length === 0) {\n            stateNoMatch(context, char, charCode);\n        } else {\n            // Must loop through the state machines backwards for when one\n            // is removed\n            for (let stateIdx = context.stateMachines.length - 1; stateIdx >= 0; stateIdx--) {\n                const stateMachine = context.stateMachines[stateIdx];\n\n                switch (stateMachine.state) {\n                    // Protocol-relative URL states\n                    case State.ProtocolRelativeSlash1:\n                        stateProtocolRelativeSlash1(context, stateMachine, charCode);\n                        break;\n                    case State.ProtocolRelativeSlash2:\n                        stateProtocolRelativeSlash2(context, stateMachine, charCode);\n                        break;\n\n                    case State.SchemeChar:\n                        stateSchemeChar(context, stateMachine, charCode);\n                        break;\n                    case State.SchemeHyphen:\n                        stateSchemeHyphen(context, stateMachine, charCode);\n                        break;\n                    case State.SchemeColon:\n                        stateSchemeColon(context, stateMachine, charCode);\n                        break;\n                    case State.SchemeSlash1:\n                        stateSchemeSlash1(context, stateMachine, charCode);\n                        break;\n                    case State.SchemeSlash2:\n                        stateSchemeSlash2(context, stateMachine, char, charCode);\n                        break;\n\n                    case State.DomainLabelChar:\n                        stateDomainLabelChar(context, stateMachine, charCode);\n                        break;\n                    case State.DomainHyphen:\n                        stateDomainHyphen(context, stateMachine, char, charCode);\n                        break;\n                    case State.DomainDot:\n                        stateDomainDot(context, stateMachine, char, charCode);\n                        break;\n\n                    case State.IpV4Digit:\n                        stateIpV4Digit(context, stateMachine as IpV4UrlStateMachine, charCode);\n                        break;\n                    case State.IpV4Dot:\n                        stateIpV4Dot(context, stateMachine as IpV4UrlStateMachine, charCode);\n                        break;\n\n                    case State.PortColon:\n                        statePortColon(context, stateMachine, charCode);\n                        break;\n                    case State.PortNumber:\n                        statePortNumber(context, stateMachine, charCode);\n                        break;\n                    case State.Path:\n                        statePath(context, stateMachine, charCode);\n                        break;\n\n                    // Email States\n                    case State.EmailMailto_M:\n                        stateEmailMailto_M(context, stateMachine, char, charCode);\n                        break;\n                    case State.EmailMailto_A:\n                        stateEmailMailto_A(context, stateMachine, char, charCode);\n                        break;\n                    case State.EmailMailto_I:\n                        stateEmailMailto_I(context, stateMachine, char, charCode);\n                        break;\n                    case State.EmailMailto_L:\n                        stateEmailMailto_L(context, stateMachine, char, charCode);\n                        break;\n                    case State.EmailMailto_T:\n                        stateEmailMailto_T(context, stateMachine, char, charCode);\n                        break;\n                    case State.EmailMailto_O:\n                        stateEmailMailto_O(context, stateMachine, charCode);\n                        break;\n                    case State.EmailMailto_Colon:\n                        stateEmailMailtoColon(context, stateMachine, charCode);\n                        break;\n                    case State.EmailLocalPart:\n                        stateEmailLocalPart(context, stateMachine, charCode);\n                        break;\n                    case State.EmailLocalPartDot:\n                        stateEmailLocalPartDot(context, stateMachine, charCode);\n                        break;\n                    case State.EmailAtSign:\n                        stateEmailAtSign(context, stateMachine, charCode);\n                        break;\n                    case State.EmailDomainChar:\n                        stateEmailDomainChar(context, stateMachine, charCode);\n                        break;\n                    case State.EmailDomainHyphen:\n                        stateEmailDomainHyphen(context, stateMachine, charCode);\n                        break;\n                    case State.EmailDomainDot:\n                        stateEmailDomainDot(context, stateMachine, charCode);\n                        break;\n\n                    // Hashtag states\n                    case State.HashtagHashChar:\n                        stateHashtagHashChar(context, stateMachine, charCode);\n                        break;\n                    case State.HashtagTextChar:\n                        stateHashtagTextChar(context, stateMachine, charCode);\n                        break;\n\n                    // Mention states\n                    case State.MentionAtChar:\n                        stateMentionAtChar(context, stateMachine, charCode);\n                        break;\n                    case State.MentionTextChar:\n                        stateMentionTextChar(context, stateMachine, charCode);\n                        break;\n\n                    // Phone number states\n                    case State.PhoneNumberOpenParen:\n                        statePhoneNumberOpenParen(context, stateMachine, char, charCode);\n                        break;\n                    case State.PhoneNumberAreaCodeDigit1:\n                        statePhoneNumberAreaCodeDigit1(context, stateMachine, charCode);\n                        break;\n                    case State.PhoneNumberAreaCodeDigit2:\n                        statePhoneNumberAreaCodeDigit2(context, stateMachine, charCode);\n                        break;\n                    case State.PhoneNumberAreaCodeDigit3:\n                        statePhoneNumberAreaCodeDigit3(context, stateMachine, charCode);\n                        break;\n                    case State.PhoneNumberCloseParen:\n                        statePhoneNumberCloseParen(context, stateMachine, char, charCode);\n                        break;\n                    case State.PhoneNumberPlus:\n                        statePhoneNumberPlus(context, stateMachine, char, charCode);\n                        break;\n                    case State.PhoneNumberDigit:\n                        statePhoneNumberDigit(context, stateMachine, char, charCode);\n                        break;\n                    case State.PhoneNumberSeparator:\n                        statePhoneNumberSeparator(context, stateMachine, char, charCode);\n                        break;\n                    case State.PhoneNumberControlChar:\n                        statePhoneNumberControlChar(context, stateMachine, charCode);\n                        break;\n                    case State.PhoneNumberPoundChar:\n                        statePhoneNumberPoundChar(context, stateMachine, charCode);\n                        break;\n\n                    /* istanbul ignore next */\n                    default:\n                        assertNever(stateMachine.state);\n                }\n            }\n\n            // Special case for handling a colon (or other non-alphanumeric)\n            // when preceded by another character, such as in the text:\n            //     Link 1:http://google.com\n            // In this case, the 'h' character after the colon wouldn't start a\n            // new scheme url because we'd be in a ipv4 or tld url and the colon\n            // would be interpreted as a port ':' char. Also, only start a new\n            // scheme url machine if there isn't currently one so we don't start\n            // new ones for colons inside a url\n            //\n            // TODO: The addition of this snippet (to fix the bug) in 4.0.1 lost\n            // us ~500 ops/sec on the benchmarks. Optimizing it with the\n            // hasSchemeUrlMachine() flag and optimizing the isSchemeStartChar()\n            // method for 4.1.3 got us back about ~400ops/sec. One potential way\n            // to improve this even ore is to add this snippet to individual\n            // state handler functions where it can occur to prevent running it\n            // on every loop interation.\n            if (\n                !context.hasSchemeUrlMachine() &&\n                context.charIdx > 0 &&\n                isSchemeStartChar(charCode)\n            ) {\n                const prevCharCode = context.text.charCodeAt(context.charIdx - 1);\n                if (!isSchemeStartChar(prevCharCode)) {\n                    context.addMachine(\n                        createSchemeUrlStateMachine(context.charIdx, State.SchemeChar)\n                    );\n                }\n            }\n        }\n\n        // For debugging: search for and uncomment other \"For debugging\" lines\n        // table.push([\n        //     String(context.charIdx),\n        //     char,\n        //     `10: ${char.charCodeAt(0)}\\n0x: ${char.charCodeAt(0).toString(16)}\\nU+${char.codePointAt(0)}`,\n        //     context.stateMachines.map(machine => `${StateMachineType[machine.type]}${'matchType' in machine ? ` (${UrlStateMachineMatchType[machine.matchType]})` : ''}`).join('\\n') || '(none)',\n        //     context.stateMachines.map(machine => State[machine.state]).join('\\n') || '(none)',\n        //     context.stateMachines.map(m => m.startIdx).join('\\n'),\n        //     context.stateMachines.map(m => m.acceptStateReached).join('\\n'),\n        // ]);\n    }\n\n    // Capture any valid match at the end of the string\n    // Note: this loop must happen in reverse because\n    // captureMatchIfValidAndRemove() removes state machines from the array\n    // and we'll end up skipping every other one if we remove while looping\n    // forward\n    for (let i = context.stateMachines.length - 1; i >= 0; i--) {\n        context.stateMachines.forEach(stateMachine =>\n            captureMatchIfValidAndRemove(context, stateMachine)\n        );\n    }\n\n    // For debugging: search for and uncomment other \"For debugging\" lines\n    // console.log(`\\nRead string:\\n  ${text}`);\n    // console.log(table.toString());\n\n    return context.matches;\n}\n\n/**\n * Handles the state when we're not in a URL/email/etc. (i.e. when no state machines exist)\n */\nfunction stateNoMatch(context: ParseMatchesContext, char: string, charCode: number): void {\n    const { charIdx } = context;\n\n    if (charCode === Char.NumberSign /* '#' */) {\n        // Hash char, start a Hashtag match\n        context.addMachine(createHashtagStateMachine(charIdx, State.HashtagHashChar));\n    } else if (charCode === Char.AtSign /* '@' */) {\n        // '@' char, start a Mention match\n        context.addMachine(createMentionStateMachine(charIdx, State.MentionAtChar));\n    } else if (charCode === Char.Slash /* '/' */) {\n        // A slash could begin a protocol-relative URL\n        context.addMachine(createTldUrlStateMachine(charIdx, State.ProtocolRelativeSlash1));\n    } else if (charCode === Char.Plus /* '+' */) {\n        // A '+' char can start a Phone number\n        context.addMachine(createPhoneNumberStateMachine(charIdx, State.PhoneNumberPlus));\n    } else if (charCode === Char.OpenParen /* '(' */) {\n        context.addMachine(createPhoneNumberStateMachine(charIdx, State.PhoneNumberOpenParen));\n    } else {\n        if (isDigitChar(charCode)) {\n            // A digit could start a phone number\n            context.addMachine(createPhoneNumberStateMachine(charIdx, State.PhoneNumberDigit));\n\n            // A digit could start an IP address\n            context.addMachine(createIpV4UrlStateMachine(charIdx, State.IpV4Digit));\n        }\n\n        if (isEmailLocalPartStartChar(charCode)) {\n            // Any email local part. An 'm' character in particular could\n            // start a 'mailto:' match\n            const startState =\n                char.toLowerCase() === 'm' ? State.EmailMailto_M : State.EmailLocalPart;\n            context.addMachine(createEmailStateMachine(charIdx, startState));\n        }\n\n        if (isSchemeStartChar(charCode)) {\n            // An uppercase or lowercase letter may start a scheme match\n            context.addMachine(createSchemeUrlStateMachine(charIdx, State.SchemeChar));\n        }\n\n        if (isAlphaNumericOrMarkChar(charCode)) {\n            // A unicode alpha character or digit could start a domain name\n            // label for a TLD match\n            context.addMachine(createTldUrlStateMachine(charIdx, State.DomainLabelChar));\n        }\n    }\n\n    // Anything else, remain in the \"non-url\" state by not creating any\n    // state machines\n}\n\n// Implements ABNF: ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\nfunction stateSchemeChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Colon /* ':' */) {\n        stateMachine.state = State.SchemeColon;\n    } else if (charCode === Char.Dash /* '-' */) {\n        stateMachine.state = State.SchemeHyphen;\n    } else if (isSchemeChar(charCode)) {\n        // Stay in SchemeChar state\n    } else {\n        // Any other character, not a scheme\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction stateSchemeHyphen(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    const { charIdx } = context;\n\n    if (charCode === Char.Dash /* '-' */) {\n        // Stay in SchemeHyphen state\n        // TODO: Should a colon following a dash be counted as the end of the scheme?\n        // } else if (char === ':') {\n        //     stateMachine.state = State.SchemeColon;\n    } else if (charCode === Char.Slash /* '/' */) {\n        // Not a valid scheme match, but may be the start of a\n        // protocol-relative match (such as //google.com)\n        context.removeMachine(stateMachine);\n        context.addMachine(createTldUrlStateMachine(charIdx, State.ProtocolRelativeSlash1));\n    } else if (isSchemeChar(charCode)) {\n        stateMachine.state = State.SchemeChar;\n    } else {\n        // Any other character, not a scheme\n        context.removeMachine(stateMachine);\n    }\n}\n\n// https://tools.ietf.org/html/rfc3986#appendix-A\nfunction stateSchemeColon(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    const { charIdx } = context;\n\n    if (charCode === Char.Slash /* '/' */) {\n        stateMachine.state = State.SchemeSlash1;\n    } else if (charCode === Char.Dot /* '.' */) {\n        // We've read something like 'hello:.' - don't capture\n        context.removeMachine(stateMachine);\n    } else if (isDomainLabelStartChar(charCode)) {\n        stateMachine.state = State.DomainLabelChar;\n\n        // It's possible that we read an \"introduction\" piece of text,\n        // and the character after the current colon actually starts an\n        // actual scheme. An example of this is:\n        //     \"The link:http://google.com\"\n        // Hence, start a new machine to capture this match if so\n        if (isSchemeStartChar(charCode)) {\n            context.addMachine(createSchemeUrlStateMachine(charIdx, State.SchemeChar));\n        }\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\n// https://tools.ietf.org/html/rfc3986#appendix-A\nfunction stateSchemeSlash1(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Slash /* '/' */) {\n        stateMachine.state = State.SchemeSlash2;\n    } else if (isPathChar(charCode)) {\n        stateMachine.state = State.Path;\n        stateMachine.acceptStateReached = true;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateSchemeSlash2(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (charCode === Char.Slash /* '/' */) {\n        // 3rd slash, must be an absolute path (`path-absolute` in the\n        // ABNF), such as in \"file:///c:/windows/etc\". See\n        // https://tools.ietf.org/html/rfc3986#appendix-A\n        stateMachine.state = State.Path;\n        stateMachine.acceptStateReached = true;\n    } else if (isDomainLabelStartChar(charCode)) {\n        // start of \"authority\" section - see https://tools.ietf.org/html/rfc3986#appendix-A\n        stateMachine.state = State.DomainLabelChar;\n        stateMachine.acceptStateReached = true;\n    } else {\n        // not valid\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles after we've read a '/' from the NonUrl state\nfunction stateProtocolRelativeSlash1(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Slash /* '/' */) {\n        stateMachine.state = State.ProtocolRelativeSlash2;\n    } else {\n        // Anything else, cannot be the start of a protocol-relative\n        // URL.\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles after we've read a second '/', which could start a protocol-relative URL\nfunction stateProtocolRelativeSlash2(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isDomainLabelStartChar(charCode)) {\n        stateMachine.state = State.DomainLabelChar;\n    } else {\n        // Anything else, not a URL\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles when we have read a domain label character\nfunction stateDomainLabelChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */) {\n        stateMachine.state = State.DomainDot;\n    } else if (charCode === Char.Dash /* '-' */) {\n        stateMachine.state = State.DomainHyphen;\n    } else if (charCode === Char.Colon /* ':' */) {\n        // Beginning of a port number, end the domain name\n        stateMachine.state = State.PortColon;\n    } else if (isUrlSuffixStartChar(charCode)) {\n        // '/', '?', or '#'\n        stateMachine.state = State.Path;\n    } else if (isDomainLabelChar(charCode)) {\n        // Stay in the DomainLabelChar state\n    } else {\n        // Anything else, end the domain name\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateDomainHyphen(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (charCode === Char.Dash /* '-' */) {\n        // Remain in the DomainHyphen state\n    } else if (charCode === Char.Dot /* '.' */) {\n        // Not valid to have a '-.' in a domain label\n        captureMatchIfValidAndRemove(context, stateMachine);\n    } else if (isDomainLabelStartChar(charCode)) {\n        stateMachine.state = State.DomainLabelChar;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateDomainDot(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */) {\n        // domain names cannot have multiple '.'s next to each other.\n        // It's possible we've already read a valid domain name though,\n        // and that the '..' sequence just forms an ellipsis at the end\n        // of a sentence\n        captureMatchIfValidAndRemove(context, stateMachine);\n    } else if (isDomainLabelStartChar(charCode)) {\n        stateMachine.state = State.DomainLabelChar;\n        stateMachine.acceptStateReached = true; // after hitting a dot, and then another domain label, we've reached an accept state\n    } else {\n        // Anything else, end the domain name\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateIpV4Digit(\n    context: ParseMatchesContext,\n    stateMachine: IpV4UrlStateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */) {\n        stateMachine.state = State.IpV4Dot;\n    } else if (charCode === Char.Colon /* ':' */) {\n        // Beginning of a port number\n        stateMachine.state = State.PortColon;\n    } else if (isDigitChar(charCode)) {\n        // stay in the IPv4 digit state\n    } else if (isUrlSuffixStartChar(charCode)) {\n        stateMachine.state = State.Path;\n    } else if (isAlphaNumericOrMarkChar(charCode)) {\n        // If we hit an alpha character, must not be an IPv4\n        // Example of this: 1.2.3.4abc\n        context.removeMachine(stateMachine);\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateIpV4Dot(\n    context: ParseMatchesContext,\n    stateMachine: IpV4UrlStateMachine,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.octetsEncountered++;\n\n        // Once we have encountered 4 octets, it's *potentially* a valid\n        // IPv4 address. Our IPv4 regex will confirm the match later\n        // though to make sure each octet is in the 0-255 range, and\n        // there's exactly 4 octets (not 5 or more)\n        if (stateMachine.octetsEncountered === 4) {\n            stateMachine.acceptStateReached = true;\n        }\n\n        stateMachine.state = State.IpV4Digit;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction statePortColon(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PortNumber;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction statePortNumber(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        // Stay in port number state\n    } else if (isUrlSuffixStartChar(charCode)) {\n        // '/', '?', or '#'\n        stateMachine.state = State.Path;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction statePath(context: ParseMatchesContext, stateMachine: StateMachine, charCode: number) {\n    if (isPathChar(charCode)) {\n        // Stay in the path state\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\n// Handles if we're reading a 'mailto:' prefix on the string\nfunction stateEmailMailto_M(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (char.toLowerCase() === 'a') {\n        stateMachine.state = State.EmailMailto_A;\n    } else {\n        stateEmailLocalPart(context, stateMachine, charCode);\n    }\n}\n\nfunction stateEmailMailto_A(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (char.toLowerCase() === 'i') {\n        stateMachine.state = State.EmailMailto_I;\n    } else {\n        stateEmailLocalPart(context, stateMachine, charCode);\n    }\n}\n\nfunction stateEmailMailto_I(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (char.toLowerCase() === 'l') {\n        stateMachine.state = State.EmailMailto_L;\n    } else {\n        stateEmailLocalPart(context, stateMachine, charCode);\n    }\n}\n\nfunction stateEmailMailto_L(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (char.toLowerCase() === 't') {\n        stateMachine.state = State.EmailMailto_T;\n    } else {\n        stateEmailLocalPart(context, stateMachine, charCode);\n    }\n}\n\nfunction stateEmailMailto_T(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (char.toLowerCase() === 'o') {\n        stateMachine.state = State.EmailMailto_O;\n    } else {\n        stateEmailLocalPart(context, stateMachine, charCode);\n    }\n}\n\nfunction stateEmailMailto_O(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Colon /* ':' */) {\n        stateMachine.state = State.EmailMailto_Colon;\n    } else {\n        stateEmailLocalPart(context, stateMachine, charCode);\n    }\n}\n\nfunction stateEmailMailtoColon(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isEmailLocalPartChar(charCode)) {\n        stateMachine.state = State.EmailLocalPart;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles the state when we're currently in the \"local part\" of an\n// email address (as opposed to the \"domain part\")\nfunction stateEmailLocalPart(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */) {\n        stateMachine.state = State.EmailLocalPartDot;\n    } else if (charCode === Char.AtSign /* '@' */) {\n        stateMachine.state = State.EmailAtSign;\n    } else if (isEmailLocalPartChar(charCode)) {\n        // stay in the \"local part\" of the email address\n        // Note: because stateEmailLocalPart() is called from the\n        // 'mailto' states (when the 'mailto' prefix itself has been\n        // broken), make sure to set the state to EmailLocalPart\n        stateMachine.state = State.EmailLocalPart;\n    } else {\n        // not an email address character\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles the state where we've read a '.' character in the local part of\n// the email address (i.e. the part before the '@' character)\nfunction stateEmailLocalPartDot(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */) {\n        // We read a second '.' in a row, not a valid email address\n        // local part\n        context.removeMachine(stateMachine);\n    } else if (charCode === Char.AtSign /* '@' */) {\n        // We read the '@' character immediately after a dot ('.'), not\n        // an email address\n        context.removeMachine(stateMachine);\n    } else if (isEmailLocalPartChar(charCode)) {\n        stateMachine.state = State.EmailLocalPart;\n    } else {\n        // Anything else, not an email address\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction stateEmailAtSign(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isDomainLabelStartChar(charCode)) {\n        stateMachine.state = State.EmailDomainChar;\n    } else {\n        // Anything else, not an email address\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction stateEmailDomainChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */) {\n        stateMachine.state = State.EmailDomainDot;\n    } else if (charCode === Char.Dash /* '-' */) {\n        stateMachine.state = State.EmailDomainHyphen;\n    } else if (isDomainLabelChar(charCode)) {\n        // Stay in the DomainChar state\n    } else {\n        // Anything else, we potentially matched if the criteria has\n        // been met\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateEmailDomainHyphen(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dash /* '-' */ || charCode === Char.Dot /* '.' */) {\n        // Not valid to have two hyphens (\"--\") or hypen+dot (\"-.\")\n        captureMatchIfValidAndRemove(context, stateMachine);\n    } else if (isDomainLabelChar(charCode)) {\n        stateMachine.state = State.EmailDomainChar;\n    } else {\n        // Anything else\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateEmailDomainDot(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */ || charCode === Char.Dash /* '-' */) {\n        // not valid to have two dots (\"..\") or dot+hypen (\".-\")\n        captureMatchIfValidAndRemove(context, stateMachine);\n    } else if (isDomainLabelStartChar(charCode)) {\n        stateMachine.state = State.EmailDomainChar;\n\n        // After having read a '.' and then a valid domain character,\n        // we now know that the domain part of the email is valid, and\n        // we have found at least a partial EmailMatch (however, the\n        // email address may have additional characters from this point)\n        stateMachine.acceptStateReached = true;\n    } else {\n        // Anything else\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\n// Handles the state when we've just encountered a '#' character\nfunction stateHashtagHashChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isHashtagTextChar(charCode)) {\n        // '#' char with valid hash text char following\n        stateMachine.state = State.HashtagTextChar;\n        stateMachine.acceptStateReached = true;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles the state when we're currently in the hash tag's text chars\nfunction stateHashtagTextChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isHashtagTextChar(charCode)) {\n        // Continue reading characters in the HashtagText state\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\n// Handles the state when we've just encountered a '@' character\nfunction stateMentionAtChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isMentionTextChar(charCode)) {\n        // '@' char with valid mention text char following\n        stateMachine.state = State.MentionTextChar;\n        stateMachine.acceptStateReached = true;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles the state when we're currently in the mention's text chars\nfunction stateMentionTextChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isMentionTextChar(charCode)) {\n        // Continue reading characters in the HashtagText state\n    } else if (isAlphaNumericOrMarkChar(charCode)) {\n        // Char is invalid for a mention text char, not a valid match.\n        // Note that ascii alphanumeric chars are okay (which are tested\n        // in the previous 'if' statement, but others are not)\n        context.removeMachine(stateMachine);\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction statePhoneNumberPlus(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberDigit;\n    } else {\n        context.removeMachine(stateMachine);\n\n        // This character may start a new match. Add states for it\n        stateNoMatch(context, char, charCode);\n    }\n}\n\nfunction statePhoneNumberOpenParen(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberAreaCodeDigit1;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n\n    // It's also possible that the paren was just an open brace for\n    // a piece of text. Start other machines\n    stateNoMatch(context, char, charCode);\n}\n\nfunction statePhoneNumberAreaCodeDigit1(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberAreaCodeDigit2;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction statePhoneNumberAreaCodeDigit2(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberAreaCodeDigit3;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction statePhoneNumberAreaCodeDigit3(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.CloseParen /* ')' */) {\n        stateMachine.state = State.PhoneNumberCloseParen;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction statePhoneNumberCloseParen(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberDigit;\n    } else if (isPhoneNumberSeparatorChar(charCode)) {\n        stateMachine.state = State.PhoneNumberSeparator;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction statePhoneNumberDigit(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    const { charIdx } = context;\n\n    // For now, if we've reached any digits, we'll say that the machine\n    // has reached its accept state. The phone regex will confirm the\n    // match later.\n    // Alternatively, we could count the number of digits to avoid\n    // invoking the phone number regex\n    stateMachine.acceptStateReached = true;\n\n    if (isPhoneNumberControlChar(charCode)) {\n        stateMachine.state = State.PhoneNumberControlChar;\n    } else if (charCode === Char.NumberSign /* '#' */) {\n        stateMachine.state = State.PhoneNumberPoundChar;\n    } else if (isDigitChar(charCode)) {\n        // Stay in the phone number digit state\n    } else if (charCode === Char.OpenParen /* '(' */) {\n        stateMachine.state = State.PhoneNumberOpenParen;\n    } else if (isPhoneNumberSeparatorChar(charCode)) {\n        stateMachine.state = State.PhoneNumberSeparator;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n\n        // The transition from a digit character to a letter can be the\n        // start of a new scheme URL match\n        if (isSchemeStartChar(charCode)) {\n            context.addMachine(createSchemeUrlStateMachine(charIdx, State.SchemeChar));\n        }\n    }\n}\n\nfunction statePhoneNumberSeparator(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberDigit;\n    } else if (charCode === Char.OpenParen /* '(' */) {\n        stateMachine.state = State.PhoneNumberOpenParen;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n\n        // This character may start a new match. Add states for it\n        stateNoMatch(context, char, charCode);\n    }\n}\n\n// The \";\" characters is \"wait\" in a phone number\n// The \",\" characters is \"pause\" in a phone number\nfunction statePhoneNumberControlChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isPhoneNumberControlChar(charCode)) {\n        // Stay in the \"control char\" state\n    } else if (charCode === Char.NumberSign /* '#' */) {\n        stateMachine.state = State.PhoneNumberPoundChar;\n    } else if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberDigit;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\n// The \"#\" characters is \"pound\" in a phone number\nfunction statePhoneNumberPoundChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isPhoneNumberControlChar(charCode)) {\n        stateMachine.state = State.PhoneNumberControlChar;\n    } else if (isDigitChar(charCode)) {\n        // According to some of the older tests, if there's a digit\n        // after a '#' sign, the match is invalid. TODO: Revisit if this is true\n        context.removeMachine(stateMachine);\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\n/*\n * Captures a match if it is valid (i.e. has a full domain name for a\n * TLD match). If a match is not valid, it is possible that we want to\n * keep reading characters in order to make a full match.\n */\nfunction captureMatchIfValidAndRemove(context: ParseMatchesContext, stateMachine: StateMachine) {\n    const {\n        matches,\n        text,\n        charIdx,\n        tagBuilder,\n        stripPrefix,\n        stripTrailingSlash,\n        decodePercentEncoding,\n        hashtagServiceName,\n        mentionServiceName,\n    } = context;\n\n    // Remove the state machine first. There are a number of code paths\n    // which return out of this function early, so make sure we have\n    // this done\n    context.removeMachine(stateMachine);\n\n    // Make sure the state machine being checked has actually reached an\n    // \"accept\" state. If it hasn't reach one, it can't be a match\n    if (!stateMachine.acceptStateReached) {\n        return;\n    }\n\n    let startIdx = stateMachine.startIdx;\n    let matchedText = text.slice(stateMachine.startIdx, charIdx);\n\n    // Handle any unbalanced braces (parens, square brackets, or curly\n    // brackets) inside the URL. This handles situations like:\n    //     The link (google.com)\n    // and\n    //     Check out this link here (en.wikipedia.org/wiki/IANA_(disambiguation))\n    //\n    // And also remove any punctuation chars at the end such as:\n    //     '?', ',', ':', '.', etc.\n    matchedText = excludeUnbalancedTrailingBracesAndPunctuation(matchedText);\n\n    switch (stateMachine.type) {\n        case StateMachineType.Url: {\n            // We don't want to accidentally match a URL that is preceded by an\n            // '@' character, which would be an email address\n            const charBeforeUrlMatch = text.charCodeAt(stateMachine.startIdx - 1);\n            if (charBeforeUrlMatch === Char.AtSign /* '@' */) {\n                return;\n            }\n\n            switch (stateMachine.matchType) {\n                case UrlStateMachineMatchType.Scheme: {\n                    // Autolinker accepts many characters in a url's scheme (like `fake://test.com`).\n                    // However, in cases where a URL is missing whitespace before an obvious link,\n                    // (for example: `nowhitespacehttp://www.test.com`), we only want the match to start\n                    // at the http:// part. We will check if the match contains a common scheme and then\n                    // shift the match to start from there.\n                    const httpSchemeMatch = httpSchemeRe.exec(matchedText);\n                    if (httpSchemeMatch) {\n                        // If we found an overmatched URL, we want to find the index\n                        // of where the match should start and shift the match to\n                        // start from the beginning of the common scheme\n                        startIdx = startIdx + httpSchemeMatch.index;\n                        matchedText = matchedText.slice(httpSchemeMatch.index);\n                    }\n\n                    if (!isValidSchemeUrl(matchedText)) {\n                        return; // not a valid match\n                    }\n                    break;\n                }\n\n                case UrlStateMachineMatchType.Tld: {\n                    if (!isValidTldMatch(matchedText)) {\n                        return; // not a valid match\n                    }\n                    break;\n                }\n\n                case UrlStateMachineMatchType.IpV4: {\n                    if (!isValidIpV4Address(matchedText)) {\n                        return; // not a valid match\n                    }\n                    break;\n                }\n\n                /* istanbul ignore next */\n                default:\n                    assertNever(stateMachine);\n            }\n\n            matches.push(\n                new UrlMatch({\n                    tagBuilder: tagBuilder,\n                    matchedText: matchedText,\n                    offset: startIdx,\n                    urlMatchType: toUrlMatchType(stateMachine.matchType),\n                    url: matchedText,\n                    protocolRelativeMatch: matchedText.slice(0, 2) === '//',\n\n                    // TODO: Do these settings need to be passed to the match,\n                    // or should we handle them here in UrlMatcher?\n                    stripPrefix: stripPrefix,\n                    stripTrailingSlash: stripTrailingSlash,\n                    decodePercentEncoding: decodePercentEncoding,\n                })\n            );\n            break;\n        }\n\n        case StateMachineType.Email: {\n            // if the email address has a valid TLD, add it to the list of matches\n            if (isValidEmail(matchedText)) {\n                matches.push(\n                    new EmailMatch({\n                        tagBuilder: tagBuilder,\n                        matchedText: matchedText,\n                        offset: startIdx,\n                        email: matchedText.replace(mailtoSchemePrefixRe, ''),\n                    })\n                );\n            }\n            break;\n        }\n\n        case StateMachineType.Hashtag: {\n            if (isValidHashtag(matchedText)) {\n                matches.push(\n                    new HashtagMatch({\n                        tagBuilder,\n                        matchedText: matchedText,\n                        offset: startIdx,\n                        serviceName: hashtagServiceName,\n                        hashtag: matchedText.slice(1),\n                    })\n                );\n            }\n            break;\n        }\n\n        case StateMachineType.Mention: {\n            if (isValidMention(matchedText, mentionServiceName)) {\n                matches.push(\n                    new MentionMatch({\n                        tagBuilder: tagBuilder,\n                        matchedText: matchedText,\n                        offset: startIdx,\n                        serviceName: mentionServiceName,\n                        mention: matchedText.slice(1), // strip off the '@' character at the beginning\n                    })\n                );\n            }\n            break;\n        }\n\n        case StateMachineType.Phone: {\n            // remove any trailing spaces that were considered as \"separator\"\n            // chars by the state machine\n            matchedText = matchedText.replace(/ +$/g, '');\n\n            if (isValidPhoneNumber(matchedText)) {\n                const cleanNumber = matchedText.replace(/[^0-9,;#]/g, ''); // strip out non-digit characters exclude comma semicolon and #\n\n                matches.push(\n                    new PhoneMatch({\n                        tagBuilder: tagBuilder,\n                        matchedText: matchedText,\n                        offset: startIdx,\n                        number: cleanNumber,\n                        plusSign: matchedText.charAt(0) === '+',\n                    })\n                );\n            }\n            break;\n        }\n\n        /* istanbul ignore next */\n        default:\n            assertNever(stateMachine);\n    }\n}\n\nexport interface ParseMatchesArgs {\n    tagBuilder: AnchorTagBuilder;\n    stripPrefix: Required<StripPrefixConfigObj>;\n    stripTrailingSlash: boolean;\n    decodePercentEncoding: boolean;\n    hashtagServiceName: HashtagService;\n    mentionServiceName: MentionService;\n}\n\n/**\n * Helper function to convert a UrlStateMachineMatchType value to its\n * UrlMatchType equivalent.\n */\nfunction toUrlMatchType(stateMachineMatchType: UrlStateMachineMatchType): UrlMatchType {\n    switch (stateMachineMatchType) {\n        case UrlStateMachineMatchType.Scheme:\n            return 'scheme';\n        case UrlStateMachineMatchType.Tld:\n            return 'tld';\n        case UrlStateMachineMatchType.IpV4:\n            return 'ipV4';\n\n        /* istanbul ignore next */\n        default:\n            assertNever(stateMachineMatchType);\n    }\n}\n\nconst oppositeBrace: { [char: string]: string } = {\n    ')': '(',\n    '}': '{',\n    ']': '[',\n};\n\n/**\n * Determines if a match found has unmatched closing parenthesis,\n * square brackets or curly brackets. If so, these unbalanced symbol(s) will be\n * removed from the URL match itself.\n *\n * A match may have an extra closing parenthesis/square brackets/curly brackets\n * at the end of the match because these are valid URL path characters. For\n * example, \"wikipedia.com/something_(disambiguation)\" should be auto-linked.\n *\n * However, an extra parenthesis *will* be included when the URL itself is\n * wrapped in parenthesis, such as in the case of:\n *\n *     \"(wikipedia.com/something_(disambiguation))\"\n *\n * In this case, the last closing parenthesis should *not* be part of the\n * URL itself, and this method will exclude it from the returned URL.\n *\n * For square brackets in URLs such as in PHP arrays, the same behavior as\n * parenthesis discussed above should happen:\n *\n *     \"[http://www.example.com/foo.php?bar[]=1&bar[]=2&bar[]=3]\"\n *\n * The very last closing square bracket should not be part of the URL itself,\n * and therefore this method will remove it.\n *\n * @param matchedText The full matched URL/email/hashtag/etc. from the state\n *   machine parser.\n * @return The updated matched text with extraneous suffix characters removed.\n */\nexport function excludeUnbalancedTrailingBracesAndPunctuation(matchedText: string): string {\n    const braceCounts: { [char: string]: number } = {\n        '(': 0,\n        '{': 0,\n        '[': 0,\n    };\n\n    for (let i = 0; i < matchedText.length; i++) {\n        const char = matchedText.charAt(i);\n        const charCode = matchedText.charCodeAt(i);\n\n        if (isOpenBraceChar(charCode)) {\n            braceCounts[char]++;\n        } else if (isCloseBraceChar(charCode)) {\n            braceCounts[oppositeBrace[char]]--;\n        }\n    }\n\n    let endIdx = matchedText.length - 1;\n    while (endIdx >= 0) {\n        const char = matchedText.charAt(endIdx);\n        const charCode = matchedText.charCodeAt(endIdx);\n\n        if (isCloseBraceChar(charCode)) {\n            const oppositeBraceChar = oppositeBrace[char];\n\n            if (braceCounts[oppositeBraceChar] < 0) {\n                braceCounts[oppositeBraceChar]++;\n                endIdx--;\n            } else {\n                break;\n            }\n        } else if (isUrlSuffixNotAllowedAsFinalChar(charCode)) {\n            // Walk back a punctuation char like '?', ',', ':', '.', etc.\n            endIdx--;\n        } else {\n            break;\n        }\n    }\n\n    return matchedText.slice(0, endIdx + 1);\n}\n\n// States for the parser\n// For debugging: temporarily remove `const` from `const enum`\nconst enum State {\n    // Scheme states\n    SchemeChar = 0, // First char must be an ASCII letter. Subsequent characters can be: ALPHA / DIGIT / \"+\" / \"-\" / \".\"\n    SchemeHyphen, // Extra state used to figure out when we can start a new match after (such as if we have '-//' which starts a protocol-relative match)\n    SchemeColon, // Once we've reached the colon character after a scheme name\n    SchemeSlash1,\n    SchemeSlash2,\n\n    DomainLabelChar, // Note: Domain labels must begin with a letter or number (no hyphens), and can include unicode letters\n    DomainHyphen,\n    DomainDot,\n    PortColon,\n    PortNumber,\n    Path,\n\n    // Protocol-relative URL states\n    ProtocolRelativeSlash1,\n    ProtocolRelativeSlash2,\n\n    // IPv4 States\n    IpV4Digit,\n    IpV4Dot,\n\n    // Email Address States\n    EmailMailto_M, // if matching a 'mailto:' prefix\n    EmailMailto_A, // if matching a 'mailto:' prefix\n    EmailMailto_I, // if matching a 'mailto:' prefix\n    EmailMailto_L, // if matching a 'mailto:' prefix\n    EmailMailto_T, // if matching a 'mailto:' prefix\n    EmailMailto_O, // if matching a 'mailto:' prefix\n    EmailMailto_Colon,\n    EmailLocalPart,\n    EmailLocalPartDot,\n    EmailAtSign,\n    EmailDomainChar,\n    EmailDomainHyphen,\n    EmailDomainDot,\n\n    // Hashtag States\n    HashtagHashChar, // When we've encountered the '#' char\n    HashtagTextChar, // Inside a hashtag char\n\n    // Mention State\n    MentionAtChar,\n    MentionTextChar,\n\n    // Phone Number States\n    PhoneNumberOpenParen,\n    PhoneNumberAreaCodeDigit1, // a digit inside area code parens, such as the '1' in '(123)456-7890'\n    PhoneNumberAreaCodeDigit2, // a digit inside area code parens, such as the '2' in '(123)456-7890'\n    PhoneNumberAreaCodeDigit3, // a digit inside area code parens, such as the '3' in '(123)456-7890'\n    PhoneNumberCloseParen,\n    PhoneNumberPlus,\n    PhoneNumberDigit, // a digit outside of area code parens\n    PhoneNumberSeparator, // '-', '.' or ' '\n    PhoneNumberControlChar, // ',' for 1 second pause, ';' for \"wait\" for user to take action\n    PhoneNumberPoundChar, // '#' for pound character\n}\n\n// The type of state machine\n// For debugging: temporarily remove `const` from `const enum`\nconst enum StateMachineType {\n    Url = 0,\n    Email,\n    Hashtag,\n    Mention,\n    Phone,\n}\n\ntype StateMachine =\n    | UrlStateMachine\n    | EmailStateMachine\n    | MentionStateMachine\n    | HashtagStateMachine\n    | PhoneNumberStateMachine;\n\ninterface AbstractStateMachine {\n    startIdx: number; // the index of the first character in the match\n    state: State;\n    acceptStateReached: boolean;\n}\n\n// The type of URL state machine\n// For debugging: temporarily remove `const` from `const enum`\nconst enum UrlStateMachineMatchType {\n    Scheme = 0, // http://, https://, file://, etc. match\n    Tld, // Top-level Domain (TLD)\n    IpV4, // 192.168.0.1\n}\n\ninterface AbstractUrlStateMachine extends AbstractStateMachine {\n    readonly type: StateMachineType.Url;\n}\n\ntype UrlStateMachine = SchemeUrlStateMachine | TldUrlStateMachine | IpV4UrlStateMachine;\n\n/**\n * State machine with metadata for capturing TLD (top-level domain) URLs.\n */\ninterface SchemeUrlStateMachine extends AbstractUrlStateMachine {\n    readonly matchType: UrlStateMachineMatchType.Scheme;\n}\n\n/**\n * State machine with metadata for capturing TLD (top-level domain) URLs.\n */\ninterface TldUrlStateMachine extends AbstractUrlStateMachine {\n    readonly matchType: UrlStateMachineMatchType.Tld;\n}\n\n/**\n * State machine for capturing IPv4 addresses that are not prefixed with a\n * scheme (such as 'http://').\n */\ninterface IpV4UrlStateMachine extends AbstractUrlStateMachine {\n    readonly matchType: UrlStateMachineMatchType.IpV4;\n    octetsEncountered: number; // if we encounter a number of octets other than 4, it's not an IPv4 address\n}\n\n/**\n * State machine for capturing email addresses.\n */\ninterface EmailStateMachine extends AbstractStateMachine {\n    readonly type: StateMachineType.Email;\n}\n\n/**\n * State machine for capturing hashtags.\n */\ninterface HashtagStateMachine extends AbstractStateMachine {\n    readonly type: StateMachineType.Hashtag;\n}\n\n/**\n * State machine for capturing hashtags.\n */\ninterface MentionStateMachine extends AbstractStateMachine {\n    readonly type: StateMachineType.Mention;\n}\n\n/**\n * State machine for capturing phone numbers.\n *\n * Note: this doesn't actually capture phone numbers at the moment, but is used\n * to exclude phone number matches from URLs where the URL matcher would\n * otherwise potentially think a phone number is part of a domain label.\n */\ninterface PhoneNumberStateMachine extends AbstractStateMachine {\n    readonly type: StateMachineType.Phone;\n}\n\nfunction createSchemeUrlStateMachine(startIdx: number, state: State): SchemeUrlStateMachine {\n    return {\n        type: StateMachineType.Url,\n        startIdx,\n        state,\n        acceptStateReached: false,\n        matchType: UrlStateMachineMatchType.Scheme,\n    };\n}\n\nfunction createTldUrlStateMachine(startIdx: number, state: State): TldUrlStateMachine {\n    return {\n        type: StateMachineType.Url,\n        startIdx,\n        state,\n        acceptStateReached: false,\n        matchType: UrlStateMachineMatchType.Tld,\n    };\n}\n\nfunction createIpV4UrlStateMachine(startIdx: number, state: State): IpV4UrlStateMachine {\n    return {\n        type: StateMachineType.Url,\n        startIdx,\n        state,\n        acceptStateReached: false,\n        matchType: UrlStateMachineMatchType.IpV4,\n        octetsEncountered: 1, // starts at 1 because we create this machine when encountering the first octet\n    };\n}\n\nfunction createEmailStateMachine(startIdx: number, state: State): EmailStateMachine {\n    return {\n        type: StateMachineType.Email,\n        startIdx,\n        state,\n        acceptStateReached: false,\n    };\n}\n\nfunction createHashtagStateMachine(startIdx: number, state: State): HashtagStateMachine {\n    return {\n        type: StateMachineType.Hashtag,\n        startIdx,\n        state,\n        acceptStateReached: false,\n    };\n}\n\nfunction createMentionStateMachine(startIdx: number, state: State): MentionStateMachine {\n    return {\n        type: StateMachineType.Mention,\n        startIdx,\n        state,\n        acceptStateReached: false,\n    };\n}\n\nfunction createPhoneNumberStateMachine(startIdx: number, state: State): PhoneNumberStateMachine {\n    return {\n        type: StateMachineType.Phone,\n        startIdx,\n        state,\n        acceptStateReached: false,\n    };\n}\n\nfunction isSchemeUrlStateMachine(machine: StateMachine): machine is SchemeUrlStateMachine {\n    return (\n        machine.type === StateMachineType.Url &&\n        machine.matchType === UrlStateMachineMatchType.Scheme\n    );\n}\n"]}