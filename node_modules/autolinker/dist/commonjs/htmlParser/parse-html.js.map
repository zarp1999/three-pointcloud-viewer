{"version":3,"file":"parse-html.js","sourceRoot":"","sources":["../../../src/htmlParser/parse-html.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    isDigitChar,\n    isAsciiLetterChar,\n    isQuoteChar,\n    isWhitespaceChar,\n    isControlChar,\n} from '../char-utils';\nimport { assertNever } from '../utils';\n\n// For debugging: search for other \"For debugging\" lines\n// import CliTable from 'cli-table';\n\nclass CurrentTag {\n    readonly idx: number; // the index of the '<' in the html string\n    readonly type: 'tag' | 'comment' | 'doctype';\n    readonly name: string;\n    readonly isOpening: boolean; // true if it's an opening tag, OR a self-closing open tag\n    readonly isClosing: boolean; // true if it's a closing tag, OR a self-closing open tag\n\n    constructor(cfg: Partial<CurrentTag> = {}) {\n        this.idx = cfg.idx !== undefined ? cfg.idx : -1;\n        this.type = cfg.type || 'tag';\n        this.name = cfg.name || '';\n        this.isOpening = !!cfg.isOpening;\n        this.isClosing = !!cfg.isClosing;\n    }\n}\n\nconst noCurrentTag = new CurrentTag(); // shared reference for when there is no current tag currently being read\n\n/**\n * Context object containing all the state needed by the HTML parsing state\n * machine function.\n *\n * ## Historical note\n *\n * In v4.1.5, we used nested functions to handle the context via closures, but\n * this necessitated re-creating the functions for each call to `parseHtml()`,\n * which made them difficult for v8 to JIT optimize. In v4.1.6, we lifted all of\n * the functions to the top-level scope and passed the context object between\n * them, which allows the functions to be JIT compiled once and reused.\n */\nclass ParseHtmlContext {\n    public charIdx = 0; // Current character index being processed\n    public readonly html: string; // The input html being parsed\n    public readonly callbacks: ParseHtmlCallbacks;\n    public state: State = State.Data; // begin in the Data state\n    public currentDataIdx = 0; // where the current data start index is\n    public currentTag: CurrentTag = noCurrentTag; // describes the current tag that is being read\n\n    constructor(html: string, callbacks: ParseHtmlCallbacks) {\n        this.html = html;\n        this.callbacks = callbacks;\n    }\n}\n\n/**\n * The callback functions that can be provided to {@link #parseHtml}.\n */\nexport interface ParseHtmlCallbacks {\n    onOpenTag: (tagName: string, offset: number) => void;\n    onCloseTag: (tagName: string, offset: number) => void;\n    onText: (text: string, offset: number) => void;\n    onComment: (offset: number) => void;\n    onDoctype: (offset: number) => void;\n}\n\n/**\n * Parses an HTML string, calling the callbacks to notify of tags and text.\n *\n * ## History\n *\n * This file previously used a regular expression to find html tags in the input\n * text. Unfortunately, we ran into a bunch of catastrophic backtracking issues\n * with certain input text, causing Autolinker to either hang or just take a\n * really long time to parse the string.\n *\n * The current code is intended to be a O(n) algorithm that walks through\n * the string in one pass, and tries to be as cheap as possible. We don't need\n * to implement the full HTML spec, but rather simply determine where the string\n * looks like an HTML tag, and where it looks like text (so that we can autolink\n * that).\n *\n * This state machine parser is intended just to be a simple but performant\n * parser of HTML for the subset of requirements we have. We simply need to:\n *\n * 1. Determine where HTML tags are\n * 2. Determine the tag name (Autolinker specifically only cares about <a>,\n *    <script>, and <style> tags, so as not to link any text within them)\n *\n * We don't need to:\n *\n * 1. Create a parse tree\n * 2. Auto-close tags with invalid markup\n * 3. etc.\n *\n * The other intention behind this is that we didn't want to add external\n * dependencies on the Autolinker utility which would increase its size. For\n * instance, adding htmlparser2 adds 125kb to the minified output file,\n * increasing its final size from 47kb to 172kb (at the time of writing). It\n * also doesn't work exactly correctly, treating the string \"<3 blah blah blah\"\n * as an HTML tag.\n *\n * Reference for HTML spec:\n *\n *     https://www.w3.org/TR/html51/syntax.html#sec-tokenization\n *\n * @param {String} html The HTML to parse\n * @param {Object} callbacks\n * @param {Function} callbacks.onOpenTag Callback function to call when an open\n *   tag is parsed. Called with the tagName as its argument.\n * @param {Function} callbacks.onCloseTag Callback function to call when a close\n *   tag is parsed. Called with the tagName as its argument. If a self-closing\n *   tag is found, `onCloseTag` is called immediately after `onOpenTag`.\n * @param {Function} callbacks.onText Callback function to call when text (i.e\n *   not an HTML tag) is parsed. Called with the text (string) as its first\n *   argument, and offset (number) into the string as its second.\n */\nexport function parseHtml(html: string, callbacks: ParseHtmlCallbacks) {\n    const context = new ParseHtmlContext(html, callbacks);\n\n    // For debugging: search for other \"For debugging\" lines\n    // const table = new CliTable( {\n    // \thead: [ 'charIdx', 'char', 'state', 'currentDataIdx', 'currentOpenTagIdx', 'tag.type' ]\n    // } );\n\n    const len = html.length;\n    while (context.charIdx < len) {\n        const char = html.charAt(context.charIdx);\n        const charCode = html.charCodeAt(context.charIdx);\n\n        // For debugging: search for other \"For debugging\" lines\n        // ALSO: Temporarily remove the 'const' keyword on the State enum\n        // table.push([\n        //     String(charIdx),\n        //     char,\n        //     State[state],\n        //     String(currentDataIdx),\n        //     String(currentTag.idx),\n        //     currentTag.idx === -1 ? '' : currentTag.type\n        // ]);\n\n        switch (context.state) {\n            case State.Data:\n                stateData(context, char);\n                break;\n            case State.TagOpen:\n                stateTagOpen(context, char, charCode);\n                break;\n            case State.EndTagOpen:\n                stateEndTagOpen(context, char, charCode);\n                break;\n            case State.TagName:\n                stateTagName(context, char, charCode);\n                break;\n            case State.BeforeAttributeName:\n                stateBeforeAttributeName(context, char, charCode);\n                break;\n            case State.AttributeName:\n                stateAttributeName(context, char, charCode);\n                break;\n            case State.AfterAttributeName:\n                stateAfterAttributeName(context, char, charCode);\n                break;\n            case State.BeforeAttributeValue:\n                stateBeforeAttributeValue(context, char, charCode);\n                break;\n            case State.AttributeValueDoubleQuoted:\n                stateAttributeValueDoubleQuoted(context, char);\n                break;\n            case State.AttributeValueSingleQuoted:\n                stateAttributeValueSingleQuoted(context, char);\n                break;\n            case State.AttributeValueUnquoted:\n                stateAttributeValueUnquoted(context, char, charCode);\n                break;\n            case State.AfterAttributeValueQuoted:\n                stateAfterAttributeValueQuoted(context, char, charCode);\n                break;\n            case State.SelfClosingStartTag:\n                stateSelfClosingStartTag(context, char);\n                break;\n            case State.MarkupDeclarationOpenState:\n                stateMarkupDeclarationOpen(context);\n                break;\n            case State.CommentStart:\n                stateCommentStart(context, char);\n                break;\n            case State.CommentStartDash:\n                stateCommentStartDash(context, char);\n                break;\n            case State.Comment:\n                stateComment(context, char);\n                break;\n            case State.CommentEndDash:\n                stateCommentEndDash(context, char);\n                break;\n            case State.CommentEnd:\n                stateCommentEnd(context, char);\n                break;\n            case State.CommentEndBang:\n                stateCommentEndBang(context, char);\n                break;\n            case State.Doctype:\n                stateDoctype(context, char);\n                break;\n\n            /* istanbul ignore next */\n            default:\n                assertNever(context.state);\n        }\n\n        // For debugging: search for other \"For debugging\" lines\n        // ALSO: Temporarily remove the 'const' keyword on the State enum\n        // table.push([\n        //     String(context.charIdx),\n        //     char,\n        //     State[context.state],\n        //     String(context.currentDataIdx),\n        //     String(context.currentTag.idx),\n        //     context.currentTag.idx === -1 ? '' : context.currentTag.type\n        // ]);\n\n        context.charIdx++;\n    }\n\n    if (context.currentDataIdx < context.charIdx) {\n        emitText(context);\n    }\n\n    // For debugging: search for other \"For debugging\" lines\n    // console.log( '\\n' + table.toString() );\n}\n\n// Called when non-tags are being read (i.e. the text around HTML †ags)\n// https://www.w3.org/TR/html51/syntax.html#data-state\nfunction stateData(context: ParseHtmlContext, char: string) {\n    if (char === '<') {\n        startNewTag(context);\n    }\n}\n\n// Called after a '<' is read from the Data state\n// https://www.w3.org/TR/html51/syntax.html#tag-open-state\nfunction stateTagOpen(context: ParseHtmlContext, char: string, charCode: number) {\n    if (char === '!') {\n        context.state = State.MarkupDeclarationOpenState;\n    } else if (char === '/') {\n        context.state = State.EndTagOpen;\n        context.currentTag = new CurrentTag({ ...context.currentTag, isClosing: true });\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else if (isAsciiLetterChar(charCode)) {\n        // tag name start (and no '/' read)\n        context.state = State.TagName;\n        context.currentTag = new CurrentTag({ ...context.currentTag, isOpening: true });\n    } else {\n        // Any other\n        context.state = State.Data;\n        context.currentTag = noCurrentTag;\n    }\n}\n\n// After a '<x', '</x' sequence is read (where 'x' is a letter character),\n// this is to continue reading the tag name\n// https://www.w3.org/TR/html51/syntax.html#tag-name-state\nfunction stateTagName(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        context.currentTag = new CurrentTag({\n            ...context.currentTag,\n            name: captureTagName(context),\n        });\n        context.state = State.BeforeAttributeName;\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else if (char === '/') {\n        context.currentTag = new CurrentTag({\n            ...context.currentTag,\n            name: captureTagName(context),\n        });\n        context.state = State.SelfClosingStartTag;\n    } else if (char === '>') {\n        context.currentTag = new CurrentTag({\n            ...context.currentTag,\n            name: captureTagName(context),\n        });\n        emitTagAndPreviousTextNode(context); // resets to Data state as well\n    } else if (!isAsciiLetterChar(charCode) && !isDigitChar(charCode) && char !== ':') {\n        // Anything else that does not form an html tag. Note: the colon\n        // character is accepted for XML namespaced tags\n        resetToDataState(context);\n    } else {\n        // continue reading tag name\n    }\n}\n\n// Called after the '/' is read from a '</' sequence\n// https://www.w3.org/TR/html51/syntax.html#end-tag-open-state\nfunction stateEndTagOpen(context: ParseHtmlContext, char: string, charCode: number) {\n    if (char === '>') {\n        // parse error. Encountered \"</>\". Skip it without treating as a tag\n        resetToDataState(context);\n    } else if (isAsciiLetterChar(charCode)) {\n        context.state = State.TagName;\n    } else {\n        // some other non-tag-like character, don't treat this as a tag\n        resetToDataState(context);\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#before-attribute-name-state\nfunction stateBeforeAttributeName(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        // stay in BeforeAttributeName state - continue reading chars\n    } else if (char === '/') {\n        context.state = State.SelfClosingStartTag;\n    } else if (char === '>') {\n        emitTagAndPreviousTextNode(context); // resets to Data state as well\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else if (char === `=` || isQuoteChar(charCode) || isControlChar(charCode)) {\n        // \"Parse error\" characters that, according to the spec, should be\n        // appended to the attribute name, but we'll treat these characters\n        // as not forming a real HTML tag\n        resetToDataState(context);\n    } else {\n        // Any other char, start of a new attribute name\n        context.state = State.AttributeName;\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#attribute-name-state\nfunction stateAttributeName(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        context.state = State.AfterAttributeName;\n    } else if (char === '/') {\n        context.state = State.SelfClosingStartTag;\n    } else if (char === '=') {\n        context.state = State.BeforeAttributeValue;\n    } else if (char === '>') {\n        emitTagAndPreviousTextNode(context); // resets to Data state as well\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else if (isQuoteChar(charCode)) {\n        // \"Parse error\" characters that, according to the spec, should be\n        // appended to the attribute name, but we'll treat these characters\n        // as not forming a real HTML tag\n        resetToDataState(context);\n    } else {\n        // anything else: continue reading attribute name\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#after-attribute-name-state\nfunction stateAfterAttributeName(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        // ignore the character - continue reading\n    } else if (char === '/') {\n        context.state = State.SelfClosingStartTag;\n    } else if (char === '=') {\n        context.state = State.BeforeAttributeValue;\n    } else if (char === '>') {\n        emitTagAndPreviousTextNode(context);\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else if (isQuoteChar(charCode)) {\n        // \"Parse error\" characters that, according to the spec, should be\n        // appended to the attribute name, but we'll treat these characters\n        // as not forming a real HTML tag\n        resetToDataState(context);\n    } else {\n        // Any other character, start a new attribute in the current tag\n        context.state = State.AttributeName;\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#before-attribute-value-state\nfunction stateBeforeAttributeValue(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        // ignore the character - continue reading\n    } else if (char === `\"`) {\n        context.state = State.AttributeValueDoubleQuoted;\n    } else if (char === `'`) {\n        context.state = State.AttributeValueSingleQuoted;\n    } else if (/[>=`]/.test(char)) {\n        // Invalid chars after an '=' for an attribute value, don't count\n        // the current tag as an HTML tag\n        resetToDataState(context);\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else {\n        // Any other character, consider it an unquoted attribute value\n        context.state = State.AttributeValueUnquoted;\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#attribute-value-double-quoted-state\nfunction stateAttributeValueDoubleQuoted(context: ParseHtmlContext, char: string) {\n    if (char === `\"`) {\n        // end the current double-quoted attribute\n        context.state = State.AfterAttributeValueQuoted;\n    } else {\n        // consume the character as part of the double-quoted attribute value\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#attribute-value-single-quoted-state\nfunction stateAttributeValueSingleQuoted(context: ParseHtmlContext, char: string) {\n    if (char === `'`) {\n        // end the current single-quoted attribute\n        context.state = State.AfterAttributeValueQuoted;\n    } else {\n        // consume the character as part of the double-quoted attribute value\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#attribute-value-unquoted-state\nfunction stateAttributeValueUnquoted(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        context.state = State.BeforeAttributeName;\n    } else if (char === '>') {\n        emitTagAndPreviousTextNode(context);\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else {\n        // Any other character, treat it as part of the attribute value\n    }\n}\n\n// Called after a double-quoted or single-quoted attribute value is read\n// (i.e. after the closing quote character)\n// https://www.w3.org/TR/html51/syntax.html#after-attribute-value-quoted-state\nfunction stateAfterAttributeValueQuoted(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        context.state = State.BeforeAttributeName;\n    } else if (char === '/') {\n        context.state = State.SelfClosingStartTag;\n    } else if (char === '>') {\n        emitTagAndPreviousTextNode(context);\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else {\n        // Any other character, \"parse error\". Spec says to switch to the\n        // BeforeAttributeState and re-consume the character, as it may be\n        // the start of a new attribute name\n        context.state = State.BeforeAttributeName;\n        reconsumeCurrentChar(context);\n    }\n}\n\n// A '/' has just been read in the current tag (presumably for '/>'), and\n// this handles the next character\n// https://www.w3.org/TR/html51/syntax.html#self-closing-start-tag-state\nfunction stateSelfClosingStartTag(context: ParseHtmlContext, char: string) {\n    if (char === '>') {\n        context.currentTag = new CurrentTag({ ...context.currentTag, isClosing: true });\n        emitTagAndPreviousTextNode(context); // resets to Data state as well\n    } else {\n        // Note: the spec calls for a character after a '/' within a start\n        // tag to go back into the BeforeAttributeName state (in order to\n        // read more attributes, but for the purposes of Autolinker, this is\n        // most likely not a valid HTML tag. For example: \"<something / other>\"\n        // state = State.BeforeAttributeName;\n\n        // Instead, just treat as regular text\n        resetToDataState(context);\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#markup-declaration-open-state\n// (HTML Comments or !DOCTYPE)\nfunction stateMarkupDeclarationOpen(context: ParseHtmlContext) {\n    const { html, charIdx } = context;\n\n    if (html.slice(charIdx, charIdx + 2) === '--') {\n        // html comment\n        context.charIdx++; // \"consume\" the second '-' character. Next loop iteration will consume the character after the '<!--' sequence\n        context.currentTag = new CurrentTag({ ...context.currentTag, type: 'comment' });\n        context.state = State.CommentStart;\n    } else if (html.slice(charIdx, charIdx + 7).toUpperCase() === 'DOCTYPE') {\n        context.charIdx += 6; // \"consume\" the characters \"OCTYPE\" (the current loop iteraction consumed the 'D'). Next loop iteration will consume the character after the '<!DOCTYPE' sequence\n        context.currentTag = new CurrentTag({ ...context.currentTag, type: 'doctype' });\n        context.state = State.Doctype;\n    } else {\n        // At this point, the spec specifies that the state machine should\n        // enter the \"bogus comment\" state, in which case any character(s)\n        // after the '<!' that were read should become an HTML comment up\n        // until the first '>' that is read (or EOF). Instead, we'll assume\n        // that a user just typed '<!' as part of some piece of non-html\n        // text\n        resetToDataState(context);\n    }\n}\n\n// Handles after the sequence '<!--' has been read\n// https://www.w3.org/TR/html51/syntax.html#comment-start-state\nfunction stateCommentStart(context: ParseHtmlContext, char: string) {\n    if (char === '-') {\n        // We've read the sequence '<!---' at this point (3 dashes)\n        context.state = State.CommentStartDash;\n    } else if (char === '>') {\n        // At this point, we'll assume the comment wasn't a real comment\n        // so we'll just emit it as data. We basically read the sequence\n        // '<!-->'\n        resetToDataState(context);\n    } else {\n        // Any other char, take it as part of the comment\n        context.state = State.Comment;\n    }\n}\n\n// We've read the sequence '<!---' at this point (3 dashes)\n// https://www.w3.org/TR/html51/syntax.html#comment-start-dash-state\nfunction stateCommentStartDash(context: ParseHtmlContext, char: string) {\n    if (char === '-') {\n        // We've read '<!----' (4 dashes) at this point\n        context.state = State.CommentEnd;\n    } else if (char === '>') {\n        // At this point, we'll assume the comment wasn't a real comment\n        // so we'll just emit it as data. We basically read the sequence\n        // '<!--->'\n        resetToDataState(context);\n    } else {\n        // Anything else, take it as a valid comment\n        context.state = State.Comment;\n    }\n}\n\n// Currently reading the comment's text (data)\n// https://www.w3.org/TR/html51/syntax.html#comment-state\nfunction stateComment(context: ParseHtmlContext, char: string) {\n    if (char === '-') {\n        context.state = State.CommentEndDash;\n    } else {\n        // Any other character, stay in the Comment state\n    }\n}\n\n// When we we've read the first dash inside a comment, it may signal the\n// end of the comment if we read another dash\n// https://www.w3.org/TR/html51/syntax.html#comment-end-dash-state\nfunction stateCommentEndDash(context: ParseHtmlContext, char: string) {\n    if (char === '-') {\n        context.state = State.CommentEnd;\n    } else {\n        // Wasn't a dash, must still be part of the comment\n        context.state = State.Comment;\n    }\n}\n\n// After we've read two dashes inside a comment, it may signal the end of\n// the comment if we then read a '>' char\n// https://www.w3.org/TR/html51/syntax.html#comment-end-state\nfunction stateCommentEnd(context: ParseHtmlContext, char: string) {\n    if (char === '>') {\n        emitTagAndPreviousTextNode(context);\n    } else if (char === '!') {\n        context.state = State.CommentEndBang;\n    } else if (char === '-') {\n        // A 3rd '-' has been read: stay in the CommentEnd state\n    } else {\n        // Anything else, switch back to the comment state since we didn't\n        // read the full \"end comment\" sequence (i.e. '-->')\n        context.state = State.Comment;\n    }\n}\n\n// We've read the sequence '--!' inside of a comment\n// https://www.w3.org/TR/html51/syntax.html#comment-end-bang-state\nfunction stateCommentEndBang(context: ParseHtmlContext, char: string) {\n    if (char === '-') {\n        // We read the sequence '--!-' inside of a comment. The last dash\n        // could signify that the comment is going to close\n        context.state = State.CommentEndDash;\n    } else if (char === '>') {\n        // End of comment with the sequence '--!>'\n        emitTagAndPreviousTextNode(context);\n    } else {\n        // The '--!' was not followed by a '>', continue reading the\n        // comment's text\n        context.state = State.Comment;\n    }\n}\n\n/**\n * For DOCTYPES in particular, we don't care about the attributes. Just\n * advance to the '>' character and emit the tag, unless we find a '<'\n * character in which case we'll start a new tag.\n *\n * Example doctype tag:\n *    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n *\n * Actual spec: https://www.w3.org/TR/html51/syntax.html#doctype-state\n */\nfunction stateDoctype(context: ParseHtmlContext, char: string) {\n    if (char === '>') {\n        emitTagAndPreviousTextNode(context);\n    } else if (char === '<') {\n        startNewTag(context);\n    } else {\n        // stay in the Doctype state\n    }\n}\n\n/**\n * Resets the state back to the Data state, and removes the current tag.\n *\n * We'll generally run this function whenever a \"parse error\" is\n * encountered, where the current tag that is being read no longer looks\n * like a real HTML tag.\n */\nfunction resetToDataState(context: ParseHtmlContext) {\n    context.state = State.Data;\n    context.currentTag = noCurrentTag;\n}\n\n/**\n * Starts a new HTML tag at the current index, ignoring any previous HTML\n * tag that was being read.\n *\n * We'll generally run this function whenever we read a new '<' character,\n * including when we read a '<' character inside of an HTML tag that we were\n * previously reading.\n */\nfunction startNewTag(context: ParseHtmlContext) {\n    context.state = State.TagOpen;\n    context.currentTag = new CurrentTag({ idx: context.charIdx });\n}\n\n/**\n * Once we've decided to emit an open tag, that means we can also emit the\n * text node before it.\n */\nfunction emitTagAndPreviousTextNode(context: ParseHtmlContext) {\n    const textBeforeTag = context.html.slice(context.currentDataIdx, context.currentTag.idx);\n    if (textBeforeTag) {\n        // the html tag was the first element in the html string, or two\n        // tags next to each other, in which case we should not emit a text\n        // node\n        context.callbacks.onText(textBeforeTag, context.currentDataIdx);\n    }\n\n    const currentTag = context.currentTag;\n    if (currentTag.type === 'comment') {\n        context.callbacks.onComment(currentTag.idx);\n    } else if (currentTag.type === 'doctype') {\n        context.callbacks.onDoctype(currentTag.idx);\n    } else {\n        if (currentTag.isOpening) {\n            context.callbacks.onOpenTag(currentTag.name, currentTag.idx);\n        }\n        if (currentTag.isClosing) {\n            // note: self-closing tags will emit both opening and closing\n            context.callbacks.onCloseTag(currentTag.name, currentTag.idx);\n        }\n    }\n\n    // Since we just emitted a tag, reset to the data state for the next char\n    resetToDataState(context);\n    context.currentDataIdx = context.charIdx + 1;\n}\n\nfunction emitText(context: ParseHtmlContext) {\n    const text = context.html.slice(context.currentDataIdx, context.charIdx);\n    context.callbacks.onText(text, context.currentDataIdx);\n\n    context.currentDataIdx = context.charIdx + 1;\n}\n\n/**\n * Captures the tag name from the start of the tag to the current character\n * index, and converts it to lower case\n */\nfunction captureTagName(context: ParseHtmlContext) {\n    const startIdx = context.currentTag.idx + (context.currentTag.isClosing ? 2 : 1);\n    return context.html.slice(startIdx, context.charIdx).toLowerCase();\n}\n\n/**\n * Causes the main loop to re-consume the current character, such as after\n * encountering a \"parse error\" that changed state and needs to reconsume\n * the same character in that new state.\n */\nfunction reconsumeCurrentChar(context: ParseHtmlContext) {\n    context.charIdx--;\n}\n\n/**\n * The subset of the parser states defined in https://www.w3.org/TR/html51/syntax.html\n * which are useful for Autolinker.\n */\n// For debugging: temporarily remove 'const' keyword on the State enum\nexport const enum State {\n    Data = 0,\n    TagOpen,\n    EndTagOpen,\n    TagName,\n    BeforeAttributeName,\n    AttributeName,\n    AfterAttributeName,\n    BeforeAttributeValue,\n    AttributeValueDoubleQuoted,\n    AttributeValueSingleQuoted,\n    AttributeValueUnquoted,\n    AfterAttributeValueQuoted,\n    SelfClosingStartTag,\n    MarkupDeclarationOpenState, // When the sequence '<!' is read for an HTML comment or doctype\n    CommentStart,\n    CommentStartDash,\n    Comment,\n    CommentEndDash,\n    CommentEnd,\n    CommentEndBang,\n    Doctype,\n}\n"]}