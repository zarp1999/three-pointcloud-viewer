import { BufferGeometry, Camera, Color, Material, RawShaderMaterial, Scene, Texture, Vector3, Vector4, WebGLRenderer } from 'three';
import { PointCloudOctree } from '../point-cloud-octree';
import { PointCloudOctreeNode } from '../point-cloud-octree-node';
import { ClipMode, IClipBox } from './clipping';
import { PointColorType, PointOpacityType, PointShape, PointSizeType, TreeType } from './enums';
import { IClassification, IGradient, IUniform } from './types';
import { ColorEncoding } from './color-encoding';
/**
 * Configuration parameters for point cloud material rendering.
 *
 * @interface IPointCloudMaterialParameters
 */
export interface IPointCloudMaterialParameters {
    /**
     * The base size of points in the point cloud.
     */
    size: number;
    /**
     * The minimum allowed size for points when scaling.
     */
    minSize: number;
    /**
     * The maximum allowed size for points when scaling.
     */
    maxSize: number;
    /**
     * The type of tree structure used for organizing the point cloud data.
     */
    treeType: TreeType;
    /**
     * Whether to use the new format for point cloud data processing.
     */
    newFormat: boolean;
}
/**
 * Interface defining uniforms for point cloud material rendering in WebGL shaders.
 * These uniforms control various aspects of point cloud visualization including
 * appearance, filtering, transformations, and rendering parameters.
 *
 * @interface IPointCloudMaterialUniforms
 */
export interface IPointCloudMaterialUniforms {
    /** Bounding box size as [width, height, depth] */
    bbSize: IUniform<[number, number, number]>;
    /** Supplement value for depth blending calculations */
    blendDepthSupplement: IUniform<number>;
    /** Hardness factor for blending operations */
    blendHardness: IUniform<number>;
    /** Lookup texture for point classification rendering */
    classificationLUT: IUniform<Texture>;
    /** Number of active clipping boxes */
    clipBoxCount: IUniform<number>;
    /** Array containing clipping box parameters */
    clipBoxes: IUniform<Float32Array>;
    /** Depth map texture for depth-based effects, null if not used */
    depthMap: IUniform<Texture | null>;
    /** Diffuse color as RGB values [r, g, b] */
    diffuse: IUniform<[number, number, number]>;
    /** Field of view angle in radians */
    fov: IUniform<number>;
    /** Gradient texture for color mapping */
    gradient: IUniform<Texture>;
    /** Maximum height value for elevation-based coloring */
    heightMax: IUniform<number>;
    /** Minimum height value for elevation-based coloring */
    heightMin: IUniform<number>;
    /** Brightness adjustment for intensity values */
    intensityBrightness: IUniform<number>;
    /** Contrast adjustment for intensity values */
    intensityContrast: IUniform<number>;
    /** Gamma correction for intensity values */
    intensityGamma: IUniform<number>;
    /** Intensity range as [min, max] values */
    intensityRange: IUniform<[number, number]>;
    /** Current level of detail */
    level: IUniform<number>;
    /** Maximum point size in pixels */
    maxSize: IUniform<number>;
    /** Minimum point size in pixels */
    minSize: IUniform<number>;
    /** Size of the octree structure */
    octreeSize: IUniform<number>;
    /** Overall opacity of the point cloud (0.0 to 1.0) */
    opacity: IUniform<number>;
    /** Point cloud index identifier */
    pcIndex: IUniform<number>;
    /** Brightness adjustment for RGB color values */
    rgbBrightness: IUniform<number>;
    /** Contrast adjustment for RGB color values */
    rgbContrast: IUniform<number>;
    /** Gamma correction for RGB color values */
    rgbGamma: IUniform<number>;
    /** Screen height in pixels */
    screenHeight: IUniform<number>;
    /** Screen width in pixels */
    screenWidth: IUniform<number>;
    /** Orthographic camera height */
    orthoHeight: IUniform<number>;
    /** Orthographic camera width */
    orthoWidth: IUniform<number>;
    /** Flag indicating whether orthographic camera is being used */
    useOrthographicCamera: IUniform<boolean>;
    /** Far clipping plane distance */
    far: IUniform<number>;
    /** Base point size */
    size: IUniform<number>;
    /** Spacing between points */
    spacing: IUniform<number>;
    /** Transformation matrix to model space */
    toModel: IUniform<number[]>;
    /** Transition factor for animations or interpolations */
    transition: IUniform<number>;
    /** Color uniform for material */
    uColor: IUniform<Color>;
    /** Texture containing visible node information */
    visibleNodes: IUniform<Texture>;
    /** Starting index for visible nodes */
    vnStart: IUniform<number>;
    /** Weight factor for classification-based coloring */
    wClassification: IUniform<number>;
    /** Weight factor for elevation-based coloring */
    wElevation: IUniform<number>;
    /** Weight factor for intensity-based coloring */
    wIntensity: IUniform<number>;
    /** Weight factor for return number-based coloring */
    wReturnNumber: IUniform<number>;
    /** Weight factor for RGB color contribution */
    wRGB: IUniform<number>;
    /** Weight factor for source ID-based coloring */
    wSourceID: IUniform<number>;
    /** Opacity attenuation factor based on distance or other criteria */
    opacityAttenuation: IUniform<number>;
    /** Threshold value for normal-based point filtering */
    filterByNormalThreshold: IUniform<number>;
    /** 3D coordinate of the highlighted point */
    highlightedPointCoordinate: IUniform<Vector3>;
    /** RGBA color for highlighted point rendering */
    highlightedPointColor: IUniform<Vector4>;
    /** Flag to enable or disable point highlighting feature */
    enablePointHighlighting: IUniform<boolean>;
    /** Scale factor for highlighted point size */
    highlightedPointScale: IUniform<number>;
    /** Scale factor for view-dependent sizing */
    viewScale: IUniform<number>;
}
export declare class PointCloudMaterial extends RawShaderMaterial {
    private static helperVec3;
    lights: boolean;
    fog: boolean;
    numClipBoxes: number;
    clipBoxes: IClipBox[];
    visibleNodesTexture: Texture | undefined;
    private visibleNodeTextureOffsets;
    private _gradient;
    private gradientTexture;
    private _classification;
    private classificationTexture;
    uniforms: IPointCloudMaterialUniforms & Record<string, IUniform<any>>;
    bbSize: [number, number, number];
    depthMap: Texture | undefined;
    fov: number;
    heightMax: number;
    heightMin: number;
    intensityBrightness: number;
    intensityContrast: number;
    intensityGamma: number;
    intensityRange: [number, number];
    maxSize: number;
    minSize: number;
    octreeSize: number;
    opacity: number;
    rgbBrightness: number;
    rgbContrast: number;
    rgbGamma: number;
    screenHeight: number;
    screenWidth: number;
    orthoWidth: number;
    orthoHeight: number;
    useOrthographicCamera: boolean;
    far: number;
    size: number;
    spacing: number;
    transition: number;
    color: Color;
    weightClassification: number;
    weightElevation: number;
    weightIntensity: number;
    weightReturnNumber: number;
    weightRGB: number;
    weightSourceID: number;
    opacityAttenuation: number;
    filterByNormalThreshold: number;
    highlightedPointCoordinate: Vector3;
    highlightedPointColor: Vector4;
    enablePointHighlighting: boolean;
    highlightedPointScale: number;
    viewScale: number;
    useClipBox: boolean;
    weighted: boolean;
    pointColorType: PointColorType;
    pointSizeType: PointSizeType;
    clipMode: ClipMode;
    useEDL: boolean;
    shape: PointShape;
    treeType: TreeType;
    pointOpacityType: PointOpacityType;
    useFilterByNormal: boolean;
    highlightPoint: boolean;
    inputColorEncoding: ColorEncoding;
    outputColorEncoding: ColorEncoding;
    private useLogDepth;
    attributes: {
        position: {
            type: string;
            value: any[];
        };
        color: {
            type: string;
            value: any[];
        };
        normal: {
            type: string;
            value: any[];
        };
        intensity: {
            type: string;
            value: any[];
        };
        classification: {
            type: string;
            value: any[];
        };
        returnNumber: {
            type: string;
            value: any[];
        };
        numberOfReturns: {
            type: string;
            value: any[];
        };
        pointSourceID: {
            type: string;
            value: any[];
        };
        indices: {
            type: string;
            value: any[];
        };
    };
    newFormat: boolean;
    constructor(parameters?: Partial<IPointCloudMaterialParameters>);
    dispose(): void;
    clearVisibleNodeTextureOffsets(): void;
    updateShaderSource(): void;
    applyDefines(shaderSrc: string): string;
    setClipBoxes(clipBoxes: IClipBox[]): void;
    get gradient(): IGradient;
    set gradient(value: IGradient);
    get classification(): IClassification;
    set classification(value: IClassification);
    private recomputeClassification;
    get elevationRange(): [number, number];
    set elevationRange(value: [number, number]);
    getUniform<K extends keyof IPointCloudMaterialUniforms>(name: K): IPointCloudMaterialUniforms[K]['value'];
    setUniform<K extends keyof IPointCloudMaterialUniforms>(name: K, value: IPointCloudMaterialUniforms[K]['value']): void;
    updateMaterial(octree: PointCloudOctree, visibleNodes: PointCloudOctreeNode[], camera: Camera, renderer: WebGLRenderer): void;
    private updateVisibilityTextureData;
    static makeOnBeforeRender(octree: PointCloudOctree, node: PointCloudOctreeNode, pcIndex?: number): (_renderer: WebGLRenderer, _scene: Scene, _camera: Camera, _geometry: BufferGeometry, material: Material) => void;
}
